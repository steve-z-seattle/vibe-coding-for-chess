<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›½é™…è±¡æ£‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #fff;
        }

        h1 {
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 2.5rem;
        }

        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        .board-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .board-wrapper {
            position: relative;
            padding: 30px;
            background: linear-gradient(145deg, #2d3748, #1a202c);
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .coordinates {
            position: absolute;
            font-size: 14px;
            font-weight: bold;
            color: #a0aec0;
        }

        .coord-file {
            bottom: 8px;
            display: flex;
            justify-content: space-around;
            width: 480px;
            left: 30px;
        }

        .coord-rank {
            left: 8px;
            display: flex;
            flex-direction: column-reverse;
            justify-content: space-around;
            height: 480px;
            top: 30px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 4px solid #4a5568;
            border-radius: 4px;
            overflow: hidden;
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        .square.light {
            background: linear-gradient(145deg, #f0d9b5, #e8cfa0);
        }

        .square.dark {
            background: linear-gradient(145deg, #b58863, #a07850);
        }

        .square:hover {
            filter: brightness(1.1);
        }

        .square.selected {
            background: linear-gradient(145deg, #7dd3fc, #38bdf8) !important;
            box-shadow: inset 0 0 15px rgba(56, 189, 248, 0.5);
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(34, 197, 94, 0.6);
            border-radius: 50%;
            pointer-events: none;
        }

        .square.valid-capture {
            background: linear-gradient(145deg, #fca5a5, #f87171) !important;
        }

        .square.last-move {
            box-shadow: inset 0 0 10px rgba(251, 191, 36, 0.6);
        }

        .square.check {
            animation: pulse-red 1s infinite;
        }

        @keyframes pulse-red {
            0%, 100% { box-shadow: inset 0 0 20px rgba(239, 68, 68, 0.8); }
            50% { box-shadow: inset 0 0 30px rgba(239, 68, 68, 1); }
        }

        .piece {
            width: 50px;
            height: 50px;
            user-select: none;
            cursor: grab;
            transition: transform 0.15s ease;
            filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.4));
            z-index: 10;
        }

        .piece:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .piece.white {
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));
        }

        .piece.black {
            filter: drop-shadow(0 0 2px rgba(255,255,255,0.2));
        }

        .info-panel {
            background: linear-gradient(145deg, #2d3748, #1a202c);
            border-radius: 16px;
            padding: 25px;
            min-width: 280px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .status-box {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .status-title {
            font-size: 14px;
            color: #a0aec0;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-text {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
        }

        .turn-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .turn-piece {
            width: 35px;
            height: 35px;
        }

        .captured-pieces {
            margin-bottom: 20px;
        }

        .captured-title {
            font-size: 12px;
            color: #a0aec0;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .captured-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            min-height: 40px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .captured-piece {
            width: 28px;
            height: 28px;
        }

        .buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        button {
            padding: 14px 24px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(145deg, #3b82f6, #2563eb);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(145deg, #60a5fa, #3b82f6);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(59, 130, 246, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(145deg, #4b5563, #374151);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(145deg, #6b7280, #4b5563);
            transform: translateY(-2px);
        }

        .btn-danger {
            background: linear-gradient(145deg, #ef4444, #dc2626);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
            transform: translateY(-2px);
        }

        .move-history {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .move-history-title {
            font-size: 12px;
            color: #a0aec0;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .move-list {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 5px 15px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
        }

        .move-number {
            color: #6b7280;
        }

        .move-white, .move-black {
            color: #e5e7eb;
        }

        /* å‡å˜å¯¹è¯æ¡† */
        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .promotion-modal.active {
            display: flex;
        }

        .promotion-dialog {
            background: linear-gradient(145deg, #2d3748, #1a202c);
            padding: 30px;
            border-radius: 16px;
            text-align: center;
        }

        .promotion-title {
            font-size: 20px;
            margin-bottom: 20px;
        }

        .promotion-options {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .promotion-piece {
            width: 55px;
            height: 55px;
            cursor: pointer;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .promotion-piece:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }

        /* æ¸¸æˆç»“æŸå¯¹è¯æ¡† */
        .game-over-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .game-over-modal.active {
            display: flex;
        }

        .game-over-dialog {
            background: linear-gradient(145deg, #2d3748, #1a202c);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
        }

        .game-over-title {
            font-size: 32px;
            margin-bottom: 15px;
        }

        .game-over-message {
            font-size: 18px;
            color: #a0aec0;
            margin-bottom: 30px;
        }

        /* å“åº”å¼ */
        @media (max-width: 768px) {
            .board {
                grid-template-columns: repeat(8, 45px);
                grid-template-rows: repeat(8, 45px);
            }
            .square {
                width: 45px;
                height: 45px;
            }
            .piece {
                width: 38px;
                height: 38px;
            }
            .board-wrapper {
                padding: 25px;
            }
            .coord-file {
                width: 360px;
            }
            .coord-rank {
                height: 360px;
            }
            h1 {
                font-size: 1.8rem;
            }
        }
    </style>
</head>
<body>
    <h1>â™” å›½é™…è±¡æ£‹</h1>
    
    <div class="game-container">
        <div class="board-section">
            <div class="board-wrapper">
                <div class="coordinates coord-rank">
                    <span>1</span><span>2</span><span>3</span><span>4</span>
                    <span>5</span><span>6</span><span>7</span><span>8</span>
                </div>
                <div class="board" id="board"></div>
                <div class="coordinates coord-file">
                    <span>a</span><span>b</span><span>c</span><span>d</span>
                    <span>e</span><span>f</span><span>g</span><span>h</span>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <div class="status-box">
                <div class="status-title">æ¸¸æˆçŠ¶æ€</div>
                <div class="status-text" id="status">ç™½æ–¹å›åˆ</div>
                <div class="turn-indicator">
                    <span>è½®åˆ°:</span>
                    <img class="turn-piece" id="turnPiece" src="pieces/w_king.svg" alt="turn indicator">
                </div>
            </div>
            
            <div class="captured-pieces">
                <div class="captured-title">ç™½æ–¹åƒæ‰çš„é»‘å­</div>
                <div class="captured-list" id="capturedByWhite"></div>
            </div>
            
            <div class="captured-pieces">
                <div class="captured-title">é»‘æ–¹åƒæ‰çš„ç™½å­</div>
                <div class="captured-list" id="capturedByBlack"></div>
            </div>
            
            <div class="move-history">
                <div class="move-history-title">èµ°æ£‹è®°å½•</div>
                <div class="move-list" id="moveList"></div>
            </div>
            
            <div class="buttons">
                <button class="btn-secondary" onclick="undoMove()">â†© æ‚”æ£‹</button>
                <button class="btn-primary" onclick="resetGame()">ğŸ”„ æ–°æ¸¸æˆ</button>
                <button class="btn-danger" onclick="flipBoard()">ğŸ”ƒ ç¿»è½¬æ£‹ç›˜</button>
            </div>
        </div>
    </div>

    <!-- å‡å˜å¯¹è¯æ¡† -->
    <div class="promotion-modal" id="promotionModal">
        <div class="promotion-dialog">
            <div class="promotion-title">é€‰æ‹©å‡å˜æ£‹å­</div>
            <div class="promotion-options" id="promotionOptions"></div>
        </div>
    </div>

    <!-- æ¸¸æˆç»“æŸå¯¹è¯æ¡† -->
    <div class="game-over-modal" id="gameOverModal">
        <div class="game-over-dialog">
            <div class="game-over-title" id="gameOverTitle">æ¸¸æˆç»“æŸ</div>
            <div class="game-over-message" id="gameOverMessage"></div>
            <button class="btn-primary" onclick="resetGame(); closeGameOverModal();">å†æ¥ä¸€å±€</button>
        </div>
    </div>

    <script>
        // æ£‹å­SVGæ–‡ä»¶è·¯å¾„
        const PIECES = {
            white: { king: 'pieces/w_king.svg', queen: 'pieces/w_queen.svg', rook: 'pieces/w_rook.svg', bishop: 'pieces/w_bishop.svg', knight: 'pieces/w_knight.svg', pawn: 'pieces/w_pawn.svg' },
            black: { king: 'pieces/b_king.svg', queen: 'pieces/b_queen.svg', rook: 'pieces/b_rook.svg', bishop: 'pieces/b_bishop.svg', knight: 'pieces/b_knight.svg', pawn: 'pieces/b_pawn.svg' }
        };

        // æ¸¸æˆçŠ¶æ€
        let board = [];
        let currentPlayer = 'white';
        let selectedSquare = null;
        let validMoves = [];
        let moveHistory = [];
        let capturedByWhite = [];
        let capturedByBlack = [];
        let isFlipped = false;
        let lastMove = null;
        let kingPositions = { white: { row: 7, col: 4 }, black: { row: 0, col: 4 } };
        let castlingRights = {
            white: { kingSide: true, queenSide: true },
            black: { kingSide: true, queenSide: true }
        };
        let enPassantTarget = null;
        let pendingPromotion = null;

        // åˆå§‹åŒ–æ£‹ç›˜
        function initBoard() {
            board = [
                [{ color: 'black', type: 'rook' }, { color: 'black', type: 'knight' }, 
                 { color: 'black', type: 'bishop' }, { color: 'black', type: 'queen' },
                 { color: 'black', type: 'king' }, { color: 'black', type: 'bishop' },
                 { color: 'black', type: 'knight' }, { color: 'black', type: 'rook' }],
                Array(8).fill(null).map(() => ({ color: 'black', type: 'pawn' })),
                Array(8).fill(null),
                Array(8).fill(null),
                Array(8).fill(null),
                Array(8).fill(null),
                Array(8).fill(null).map(() => ({ color: 'white', type: 'pawn' })),
                [{ color: 'white', type: 'rook' }, { color: 'white', type: 'knight' },
                 { color: 'white', type: 'bishop' }, { color: 'white', type: 'queen' },
                 { color: 'white', type: 'king' }, { color: 'white', type: 'bishop' },
                 { color: 'white', type: 'knight' }, { color: 'white', type: 'rook' }]
            ];
            
            currentPlayer = 'white';
            selectedSquare = null;
            validMoves = [];
            moveHistory = [];
            capturedByWhite = [];
            capturedByBlack = [];
            lastMove = null;
            kingPositions = { white: { row: 7, col: 4 }, black: { row: 0, col: 4 } };
            castlingRights = {
                white: { kingSide: true, queenSide: true },
                black: { kingSide: true, queenSide: true }
            };
            enPassantTarget = null;
            pendingPromotion = null;
            
            renderBoard();
            updateStatus();
            updateCapturedPieces();
            updateMoveList();
        }

        // æ¸²æŸ“æ£‹ç›˜
        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const displayRow = isFlipped ? 7 - row : row;
                    const displayCol = isFlipped ? 7 - col : col;
                    const piece = board[displayRow][displayCol];
                    
                    const square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = displayRow;
                    square.dataset.col = displayCol;
                    
                    // é«˜äº®é€‰ä¸­çš„æ ¼å­
                    if (selectedSquare && selectedSquare.row === displayRow && selectedSquare.col === displayCol) {
                        square.classList.add('selected');
                    }
                    
                    // é«˜äº®æœ‰æ•ˆç§»åŠ¨
                    if (validMoves.some(m => m.row === displayRow && m.col === displayCol)) {
                        if (board[displayRow][displayCol]) {
                            square.classList.add('valid-capture');
                        } else {
                            square.classList.add('valid-move');
                        }
                    }
                    
                    // é«˜äº®ä¸Šä¸€æ­¥
                    if (lastMove) {
                        if ((lastMove.from.row === displayRow && lastMove.from.col === displayCol) ||
                            (lastMove.to.row === displayRow && lastMove.to.col === displayCol)) {
                            square.classList.add('last-move');
                        }
                    }
                    
                    // é«˜äº®è¢«å°†å†›çš„ç‹
                    if (piece && piece.type === 'king') {
                        if (isInCheck(piece.color)) {
                            square.classList.add('check');
                        }
                    }
                    
                    // æ¸²æŸ“æ£‹å­
                    if (piece) {
                        const pieceEl = document.createElement('img');
                        pieceEl.className = 'piece ' + piece.color;
                        pieceEl.src = PIECES[piece.color][piece.type];
                        pieceEl.alt = piece.type;
                        pieceEl.draggable = false;
                        square.appendChild(pieceEl);
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(displayRow, displayCol));
                    boardEl.appendChild(square);
                }
            }
        }

        // å¤„ç†æ ¼å­ç‚¹å‡»
        function handleSquareClick(row, col) {
            if (pendingPromotion) return;
            
            const piece = board[row][col];
            
            // å¦‚æœç‚¹å‡»äº†æœ‰æ•ˆç§»åŠ¨ä½ç½®
            if (selectedSquare && validMoves.some(m => m.row === row && m.col === col)) {
                // æ£€æŸ¥æ˜¯å¦æ˜¯å…µå‡å˜
                const movingPiece = board[selectedSquare.row][selectedSquare.col];
                if (movingPiece.type === 'pawn' && (row === 0 || row === 7)) {
                    pendingPromotion = { from: selectedSquare, to: { row, col } };
                    showPromotionDialog();
                    return;
                }
                
                makeMove(selectedSquare, { row, col });
                return;
            }
            
            // å¦‚æœç‚¹å‡»äº†è‡ªå·±çš„æ£‹å­ï¼Œé€‰ä¸­å®ƒ
            if (piece && piece.color === currentPlayer) {
                selectedSquare = { row, col };
                validMoves = getValidMoves(row, col);
                renderBoard();
                return;
            }
            
            // å–æ¶ˆé€‰æ‹©
            selectedSquare = null;
            validMoves = [];
            renderBoard();
        }

        // è·å–æœ‰æ•ˆç§»åŠ¨ï¼ˆåŒ…å«å°†å†›æ£€æŸ¥ï¼‰
        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            
            const moves = getPossibleMoves(row, col);
            
            // è¿‡æ»¤æ‰ä¼šå¯¼è‡´è‡ªå·±è¢«å°†å†›çš„ç§»åŠ¨
            return moves.filter(move => {
                // æ¨¡æ‹Ÿç§»åŠ¨
                const originalTarget = board[move.row][move.col];
                const originalKingPos = { ...kingPositions[piece.color] };
                
                board[move.row][move.col] = piece;
                board[row][col] = null;
                
                // æ›´æ–°ç‹çš„ä½ç½®
                if (piece.type === 'king') {
                    kingPositions[piece.color] = { row: move.row, col: move.col };
                }
                
                // æ£€æŸ¥æ˜¯å¦è¢«å°†å†›
                const inCheck = isInCheck(piece.color);
                
                // æ¢å¤
                board[row][col] = piece;
                board[move.row][move.col] = originalTarget;
                kingPositions[piece.color] = originalKingPos;
                
                return !inCheck;
            });
        }

        // è·å–å¯èƒ½çš„ç§»åŠ¨ï¼ˆä¸è€ƒè™‘å°†å†›ï¼‰
        function getPossibleMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            
            const moves = [];
            
            switch (piece.type) {
                case 'pawn':
                    moves.push(...getPawnMoves(row, col, piece.color));
                    break;
                case 'knight':
                    moves.push(...getKnightMoves(row, col, piece.color));
                    break;
                case 'bishop':
                    moves.push(...getBishopMoves(row, col, piece.color));
                    break;
                case 'rook':
                    moves.push(...getRookMoves(row, col, piece.color));
                    break;
                case 'queen':
                    moves.push(...getBishopMoves(row, col, piece.color));
                    moves.push(...getRookMoves(row, col, piece.color));
                    break;
                case 'king':
                    moves.push(...getKingMoves(row, col, piece.color));
                    break;
            }
            
            return moves;
        }

        // å…µçš„ç§»åŠ¨
        function getPawnMoves(row, col, color) {
            const moves = [];
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            
            // å‘å‰ä¸€æ ¼
            if (isValidSquare(row + direction, col) && !board[row + direction][col]) {
                moves.push({ row: row + direction, col });
                
                // å‘å‰ä¸¤æ ¼ï¼ˆèµ·å§‹ä½ç½®ï¼‰
                if (row === startRow && !board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col });
                }
            }
            
            // æ–œå‘åƒå­
            for (const dc of [-1, 1]) {
                const newCol = col + dc;
                if (isValidSquare(row + direction, newCol)) {
                    const target = board[row + direction][newCol];
                    if (target && target.color !== color) {
                        moves.push({ row: row + direction, col: newCol });
                    }
                    
                    // åƒè¿‡è·¯å…µ
                    if (enPassantTarget && 
                        enPassantTarget.row === row + direction && 
                        enPassantTarget.col === newCol) {
                        moves.push({ row: row + direction, col: newCol, enPassant: true });
                    }
                }
            }
            
            return moves;
        }

        // é©¬çš„ç§»åŠ¨
        function getKnightMoves(row, col, color) {
            const moves = [];
            const deltas = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
            
            for (const [dr, dc] of deltas) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidSquare(newRow, newCol)) {
                    const target = board[newRow][newCol];
                    if (!target || target.color !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            
            return moves;
        }

        // è±¡çš„ç§»åŠ¨
        function getBishopMoves(row, col, color) {
            return getSlidingMoves(row, col, color, [[-1,-1],[-1,1],[1,-1],[1,1]]);
        }

        // è½¦çš„ç§»åŠ¨
        function getRookMoves(row, col, color) {
            return getSlidingMoves(row, col, color, [[-1,0],[1,0],[0,-1],[0,1]]);
        }

        // æ»‘åŠ¨æ£‹å­çš„é€šç”¨ç§»åŠ¨
        function getSlidingMoves(row, col, color, directions) {
            const moves = [];
            
            for (const [dr, dc] of directions) {
                let newRow = row + dr;
                let newCol = col + dc;
                
                while (isValidSquare(newRow, newCol)) {
                    const target = board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (target.color !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                    newRow += dr;
                    newCol += dc;
                }
            }
            
            return moves;
        }

        // ç‹çš„ç§»åŠ¨
        function getKingMoves(row, col, color) {
            const moves = [];
            const deltas = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
            
            for (const [dr, dc] of deltas) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidSquare(newRow, newCol)) {
                    const target = board[newRow][newCol];
                    if (!target || target.color !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            
            // ç‹è½¦æ˜“ä½
            if (!isInCheck(color)) {
                // ç‹ç¿¼æ˜“ä½
                if (canCastle(color, 'kingSide')) {
                    moves.push({ row, col: col + 2, castling: 'kingSide' });
                }
                // åç¿¼æ˜“ä½
                if (canCastle(color, 'queenSide')) {
                    moves.push({ row, col: col - 2, castling: 'queenSide' });
                }
            }
            
            return moves;
        }

        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ˜“ä½
        function canCastle(color, side) {
            const row = color === 'white' ? 7 : 0;
            const rights = castlingRights[color][side];
            
            if (!rights) return false;
            
            if (side === 'kingSide') {
                // æ£€æŸ¥få’Œgæ ¼æ˜¯å¦ä¸ºç©º
                if (board[row][5] || board[row][6]) return false;
                // æ£€æŸ¥ç‹ç»è¿‡çš„æ ¼å­æ˜¯å¦è¢«æ”»å‡»
                if (isSquareAttacked(row, 5, color) || isSquareAttacked(row, 6, color)) return false;
            } else {
                // æ£€æŸ¥bã€cã€dæ ¼æ˜¯å¦ä¸ºç©º
                if (board[row][1] || board[row][2] || board[row][3]) return false;
                // æ£€æŸ¥ç‹ç»è¿‡çš„æ ¼å­æ˜¯å¦è¢«æ”»å‡»
                if (isSquareAttacked(row, 2, color) || isSquareAttacked(row, 3, color)) return false;
            }
            
            return true;
        }

        // æ£€æŸ¥æ ¼å­æ˜¯å¦æœ‰æ•ˆ
        function isValidSquare(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        // æ£€æŸ¥æŸè‰²æ˜¯å¦è¢«å°†å†›
        function isInCheck(color) {
            const kingPos = kingPositions[color];
            return isSquareAttacked(kingPos.row, kingPos.col, color);
        }

        // æ£€æŸ¥æ ¼å­æ˜¯å¦è¢«æŸæ–¹æ”»å‡»
        function isSquareAttacked(row, col, defendingColor) {
            const attackingColor = defendingColor === 'white' ? 'black' : 'white';
            
            // æ£€æŸ¥æ‰€æœ‰å¯¹æ–¹æ£‹å­çš„æ”»å‡»èŒƒå›´
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === attackingColor) {
                        // ç‰¹æ®Šå¤„ç†å…µï¼ˆå› ä¸ºå…µçš„åƒå­æ–¹å‘æ˜¯æ–œå‘ï¼‰
                        if (piece.type === 'pawn') {
                            const direction = attackingColor === 'white' ? -1 : 1;
                            if (r + direction === row && Math.abs(c - col) === 1) {
                                return true;
                            }
                        } else if (piece.type === 'king') {
                            if (Math.abs(r - row) <= 1 && Math.abs(c - col) <= 1) {
                                return true;
                            }
                        } else {
                            const moves = getPossibleMoves(r, c);
                            if (moves.some(m => m.row === row && m.col === col)) {
                                return true;
                            }
                        }
                    }
                }
            }
            
            return false;
        }

        // æ‰§è¡Œç§»åŠ¨
        function makeMove(from, to, promotionPiece = null) {
            const piece = board[from.row][from.col];
            let captured = board[to.row][to.col];
            let moveNotation = '';
            
            // åƒè¿‡è·¯å…µ
            if (to.enPassant) {
                const capturedRow = currentPlayer === 'white' ? to.row + 1 : to.row - 1;
                captured = board[capturedRow][to.col];
                board[capturedRow][to.col] = null;
            }
            
            // è®°å½•åƒå­
            if (captured) {
                if (currentPlayer === 'white') {
                    capturedByWhite.push(captured);
                } else {
                    capturedByBlack.push(captured);
                }
            }
            
            // ç‹è½¦æ˜“ä½
            if (to.castling) {
                const row = from.row;
                if (to.castling === 'kingSide') {
                    board[row][5] = board[row][7];
                    board[row][7] = null;
                    moveNotation = 'O-O';
                } else {
                    board[row][3] = board[row][0];
                    board[row][0] = null;
                    moveNotation = 'O-O-O';
                }
                castlingRights[currentPlayer].kingSide = false;
                castlingRights[currentPlayer].queenSide = false;
            }
            
            // æ›´æ–°ç‹çš„æ˜“ä½æƒåˆ©
            if (piece.type === 'king') {
                castlingRights[currentPlayer].kingSide = false;
                castlingRights[currentPlayer].queenSide = false;
            }
            if (piece.type === 'rook') {
                if (from.col === 0) castlingRights[currentPlayer].queenSide = false;
                if (from.col === 7) castlingRights[currentPlayer].kingSide = false;
            }
            
            // ç§»åŠ¨æ£‹å­
            board[to.row][to.col] = piece;
            board[from.row][from.col] = null;
            
            // å‡å˜
            if (promotionPiece) {
                board[to.row][to.col] = { color: currentPlayer, type: promotionPiece };
            }
            
            // æ›´æ–°ç‹çš„ä½ç½®
            if (piece.type === 'king') {
                kingPositions[currentPlayer] = { row: to.row, col: to.col };
            }
            
            // è®¾ç½®åƒè¿‡è·¯å…µç›®æ ‡
            if (piece.type === 'pawn' && Math.abs(to.row - from.row) === 2) {
                enPassantTarget = {
                    row: (from.row + to.row) / 2,
                    col: from.col
                };
            } else {
                enPassantTarget = null;
            }
            
            // ç”Ÿæˆè®°è°±
            if (!to.castling) {
                moveNotation = getMoveNotation(piece, from, to, captured, promotionPiece);
            }
            
            // è®°å½•ç§»åŠ¨
            lastMove = { from, to };
            moveHistory.push({
                piece: piece,
                from: from,
                to: to,
                notation: moveNotation,
                captured: captured,
                board: JSON.parse(JSON.stringify(board)),
                castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                kingPositions: JSON.parse(JSON.stringify(kingPositions)),
                enPassantTarget: enPassantTarget,
                currentPlayer: currentPlayer
            });
            
            // åˆ‡æ¢ç©å®¶
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            // æ£€æŸ¥æ¸¸æˆç»“æŸ
            checkGameEnd();
            
            // é‡ç½®é€‰æ‹©
            selectedSquare = null;
            validMoves = [];
            
            renderBoard();
            updateStatus();
            updateCapturedPieces();
            updateMoveList();
        }

        // ç”Ÿæˆä»£æ•°è®°è°±
        function getMoveNotation(piece, from, to, captured, promotion) {
            let notation = '';
            
            // æ£‹å­ç¬¦å·
            if (piece.type !== 'pawn') {
                notation += piece.type.charAt(0).toUpperCase();
            }
            
            // æ–‡ä»¶ï¼ˆåˆ—ï¼‰
            if (piece.type === 'pawn' && captured) {
                notation += String.fromCharCode(97 + from.col);
            }
            
            // åƒå­
            if (captured) {
                notation += 'x';
            }
            
            // ç›®æ ‡ä½ç½®
            notation += String.fromCharCode(97 + to.col);
            notation += (8 - to.row);
            
            // å‡å˜
            if (promotion) {
                notation += '=' + promotion.charAt(0).toUpperCase();
            }
            
            return notation;
        }

        // æ£€æŸ¥æ¸¸æˆç»“æŸ
        function checkGameEnd() {
            // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•åˆæ³•ç§»åŠ¨
            const hasValidMoves = hasAnyValidMoves(currentPlayer);
            const inCheck = isInCheck(currentPlayer);
            
            if (!hasValidMoves) {
                if (inCheck) {
                    // å°†æ€
                    const winner = currentPlayer === 'white' ? 'é»‘æ–¹' : 'ç™½æ–¹';
                    showGameOver(`${winner}è·èƒœï¼`, `æ­å–œ${winner}é€šè¿‡å°†æ€èµ¢å¾—äº†æ¯”èµ›ï¼`);
                } else {
                    // é€¼å’Œ
                    showGameOver('å’Œæ£‹', 'é€¼å’Œ - åŒæ–¹éƒ½æ— æ³•å°†æ­»å¯¹æ–¹');
                }
                return;
            }
            
            // æ£€æŸ¥ insufficient material
            if (isInsufficientMaterial()) {
                showGameOver('å’Œæ£‹', 'ææ–™ä¸è¶³ - åŒæ–¹éƒ½æ— æ³•å°†æ­»å¯¹æ–¹');
            }
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•åˆæ³•ç§»åŠ¨
        function hasAnyValidMoves(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === color) {
                        const moves = getValidMoves(row, col);
                        if (moves.length > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // æ£€æŸ¥ææ–™ä¸è¶³
        function isInsufficientMaterial() {
            const pieces = { white: [], black: [] };
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type !== 'king') {
                        pieces[piece.color].push({ ...piece, row, col });
                    }
                }
            }
            
            // ç‹å¯¹ç‹
            if (pieces.white.length === 0 && pieces.black.length === 0) {
                return true;
            }
            
            // ç‹å’Œè±¡å¯¹ç‹ï¼Œæˆ–ç‹å’Œé©¬å¯¹ç‹
            if ((pieces.white.length === 0 && pieces.black.length === 1) ||
                (pieces.black.length === 0 && pieces.white.length === 1)) {
                const lonePiece = pieces.white.length === 1 ? pieces.white[0] : pieces.black[0];
                if (lonePiece.type === 'bishop' || lonePiece.type === 'knight') {
                    return true;
                }
            }
            
            // åŒæ–¹å„åªæœ‰ä¸€ä¸ªè±¡ï¼Œä¸”åŒè‰²æ ¼
            if (pieces.white.length === 1 && pieces.black.length === 1 &&
                pieces.white[0].type === 'bishop' && pieces.black[0].type === 'bishop') {
                const whiteBishopSquare = pieces.white[0].row + pieces.white[0].col;
                const blackBishopSquare = pieces.black[0].row + pieces.black[0].col;
                if (whiteBishopSquare % 2 === blackBishopSquare % 2) {
                    return true;
                }
            }
            
            return false;
        }

        // æ˜¾ç¤ºå‡å˜å¯¹è¯æ¡†
        function showPromotionDialog() {
            const modal = document.getElementById('promotionModal');
            const options = document.getElementById('promotionOptions');
            options.innerHTML = '';
            
            const pieces = ['queen', 'rook', 'bishop', 'knight'];
            pieces.forEach(type => {
                const pieceEl = document.createElement('img');
                pieceEl.className = 'promotion-piece';
                pieceEl.src = PIECES[currentPlayer][type];
                pieceEl.alt = type;
                pieceEl.onclick = () => {
                    completePromotion(type);
                };
                options.appendChild(pieceEl);
            });
            
            modal.classList.add('active');
        }

        // å®Œæˆå‡å˜
        function completePromotion(pieceType) {
            document.getElementById('promotionModal').classList.remove('active');
            makeMove(pendingPromotion.from, pendingPromotion.to, pieceType);
            pendingPromotion = null;
        }

        // æ˜¾ç¤ºæ¸¸æˆç»“æŸ
        function showGameOver(title, message) {
            document.getElementById('gameOverTitle').textContent = title;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOverModal').classList.add('active');
        }

        // å…³é—­æ¸¸æˆç»“æŸå¯¹è¯æ¡†
        function closeGameOverModal() {
            document.getElementById('gameOverModal').classList.remove('active');
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus() {
            const statusEl = document.getElementById('status');
            const turnPieceEl = document.getElementById('turnPiece');
            
            if (isInCheck(currentPlayer)) {
                statusEl.textContent = (currentPlayer === 'white' ? 'ç™½æ–¹' : 'é»‘æ–¹') + 'è¢«å°†å†›ï¼';
                statusEl.style.color = '#ef4444';
            } else {
                statusEl.textContent = (currentPlayer === 'white' ? 'ç™½æ–¹' : 'é»‘æ–¹') + 'å›åˆ';
                statusEl.style.color = '#fff';
            }
            
            turnPieceEl.src = PIECES[currentPlayer].king;
            turnPieceEl.alt = currentPlayer + ' king';
        }

        // æ›´æ–°åƒå­æ˜¾ç¤º
        function updateCapturedPieces() {
            const whiteEl = document.getElementById('capturedByWhite');
            const blackEl = document.getElementById('capturedByBlack');
            
            whiteEl.innerHTML = capturedByWhite.map(p => 
                `<img class="captured-piece" src="${PIECES.black[p.type]}" alt="${p.type}">`
            ).join('');
            
            blackEl.innerHTML = capturedByBlack.map(p => 
                `<img class="captured-piece" src="${PIECES.white[p.type]}" alt="${p.type}">`
            ).join('');
        }

        // æ›´æ–°èµ°æ£‹è®°å½•
        function updateMoveList() {
            const moveListEl = document.getElementById('moveList');
            moveListEl.innerHTML = '';
            
            for (let i = 0; i < moveHistory.length; i += 2) {
                const moveNum = document.createElement('span');
                moveNum.className = 'move-number';
                moveNum.textContent = Math.floor(i / 2) + 1 + '.';
                moveListEl.appendChild(moveNum);
                
                const whiteMove = document.createElement('span');
                whiteMove.className = 'move-white';
                whiteMove.textContent = moveHistory[i].notation;
                moveListEl.appendChild(whiteMove);
                
                if (moveHistory[i + 1]) {
                    const blackMove = document.createElement('span');
                    blackMove.className = 'move-black';
                    blackMove.textContent = moveHistory[i + 1].notation;
                    moveListEl.appendChild(blackMove);
                }
            }
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            moveListEl.parentElement.scrollTop = moveListEl.parentElement.scrollHeight;
        }

        // æ‚”æ£‹
        function undoMove() {
            if (moveHistory.length < 2) return;
            
            // å›é€€ä¸¤æ­¥ï¼ˆåŒæ–¹å„ä¸€æ­¥ï¼‰
            moveHistory.pop(); // æ’¤é”€å½“å‰ç©å®¶çš„æœ€åä¸€æ­¥
            const lastState = moveHistory.pop(); // æ’¤é”€å¯¹æ‰‹çš„æœ€åä¸€æ­¥
            
            // æ¢å¤çŠ¶æ€
            board = lastState.board;
            castlingRights = lastState.castlingRights;
            kingPositions = lastState.kingPositions;
            enPassantTarget = lastState.enPassantTarget;
            currentPlayer = lastState.currentPlayer;
            
            // æ¢å¤åƒå­è®°å½•
            capturedByWhite = [];
            capturedByBlack = [];
            for (const move of moveHistory) {
                if (move.captured) {
                    if (move.piece.color === 'white') {
                        capturedByWhite.push(move.captured);
                    } else {
                        capturedByBlack.push(move.captured);
                    }
                }
            }
            
            // æ›´æ–°ä¸Šä¸€æ­¥
            if (moveHistory.length > 0) {
                lastMove = { 
                    from: moveHistory[moveHistory.length - 1].from,
                    to: moveHistory[moveHistory.length - 1].to
                };
            } else {
                lastMove = null;
            }
            
            selectedSquare = null;
            validMoves = [];
            
            renderBoard();
            updateStatus();
            updateCapturedPieces();
            updateMoveList();
        }

        // æ–°æ¸¸æˆ
        function resetGame() {
            initBoard();
        }

        // ç¿»è½¬æ£‹ç›˜
        function flipBoard() {
            isFlipped = !isFlipped;
            renderBoard();
        }

        // åˆå§‹åŒ–
        initBoard();
    </script>
</body>
</html>
